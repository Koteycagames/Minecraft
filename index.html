<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Minecraft JS: Anti-Cheat System</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        :root { --mc-btn-bg: #777; --mc-btn-border-light: #aaa; --mc-btn-border-dark: #555; }
        
        .menu-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: url('./textures/dirt.png'); 
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
        }
        .menu-screen::before {
            content: ""; position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); z-index: -1;
        }

        .mc-btn {
            width: 300px; height: 40px; margin: 5px;
            font-family: sans-serif; font-size: 16px; color: #ddd; text-shadow: 1px 1px #000;
            background-color: var(--mc-btn-bg); border: 2px solid;
            border-color: var(--mc-btn-border-light) var(--mc-btn-border-dark) var(--mc-btn-border-dark) var(--mc-btn-border-light);
            cursor: pointer;
        }
        .mc-btn:hover { background-color: #888; color: #fff; }
        .mc-btn:active { border-color: var(--mc-btn-border-dark) var(--mc-btn-border-light) var(--mc-btn-border-light) var(--mc-btn-border-dark); }
        
        h1 { color: #ddd; font-size: 40px; text-shadow: 2px 2px #000; margin-bottom: 20px; font-family: sans-serif; }
        .mc-input {
            width: 290px; height: 30px; margin-bottom: 10px;
            background: #000; border: 1px solid #aaa; color: #fff; padding: 5px; font-size: 16px;
        }

        #server-list, #world-list {
            width: 400px; max-height: 250px; overflow-y: auto;
            background: rgba(0,0,0,0.5); border: 1px solid #555; margin-bottom: 15px;
        }
        .list-item {
            padding: 10px; color: white; border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
        }
        .list-item:hover { background: rgba(255,255,255,0.1); }
        
        .status-active { color: #55ff55; font-size: 12px; margin-left: 10px; }
        .del-btn { background: #aa0000; padding: 2px 6px; cursor: pointer; border: 1px solid #fff; font-size: 12px; }

        /* Игровой интерфейс */
        #game-ui { display: none; } 
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #lobby-info {
            position: absolute; top: 10px; right: 10px; color: yellow; font-weight: bold;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; pointer-events: none; display: none;
        }
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(0, 0, 0, 0.5); padding: 10px;
            border-radius: 10px; z-index: 150; pointer-events: none; 
        }
        .slot {
            width: 60px; height: 60px; border: 4px solid #555; background-color: rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            color: white; font-weight: bold; font-size: 20px;
            background-size: cover; cursor: pointer; pointer-events: auto;
        }
        .slot.active { border-color: white; transform: scale(1.1); background-color: rgba(255, 255, 255, 0.1); }
        
        #inventory-screen, #pause-menu {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 100; 
            justify-content: center; align-items: center; flex-direction: column;
        }
        #inventory-container { background: #c6c6c6; padding: 20px; border: 4px solid #555; width: 400px; display: flex; flex-direction: column; gap: 20px; }
        .inv-grid { display: flex; gap: 10px; flex-wrap: wrap; }
        .inv-slot { width: 50px; height: 50px; border: 2px solid #888; background: #8b8b8b; cursor: pointer; background-size: cover; }
        #cursor-item { position: absolute; width: 40px; height: 40px; pointer-events: none; z-index: 200; background-size: cover; display: none; border: 2px solid yellow; }

        .auth-form { display: flex; flex-direction: column; align-items: center; }
        .link-text { color: #aaa; text-decoration: underline; cursor: pointer; margin-top: 10px; font-size: 14px; }
        .error-msg { color: #ff5555; margin-bottom: 10px; font-weight: bold; display: none; }

        /* ЭКРАН ANTI-CHEAT */
        #screen-blocked {
            background: #000 !important;
            color: red;
            text-align: center;
        }
        .error-code { font-size: 100px; margin: 0; }
        .error-desc { font-size: 24px; color: white; margin-bottom: 30px; }
    </style>
</head>
<body>

    <div id="screen-blocked" class="menu-screen">
        <h1 class="error-code">⚠️</h1>
        <h1>ANTI-CHEAT SYSTEM</h1>
        <div class="error-desc">Обнаружен двойной вход в аккаунт.<br>Игра запущена на другом устройстве или в другой вкладке.</div>
        <button class="mc-btn" onclick="location.reload()">Попробовать снова</button>
    </div>

    <div id="screen-auth" class="menu-screen" style="display: flex;">
        <h1 id="auth-title">ВХОД</h1>
        <div id="auth-error" class="error-msg">Ошибка входа</div>
        
        <div class="auth-form">
            <input type="email" id="auth-email" class="mc-input" placeholder="Email">
            <input type="password" id="auth-pass" class="mc-input" placeholder="Пароль">
            <input type="text" id="auth-nick" class="mc-input" placeholder="Никнейм" style="display: none;">
            
            <button class="mc-btn" id="btn-auth-action" onclick="handleAuth()">ВОЙТИ</button>
            <div class="link-text" id="auth-toggle" onclick="toggleAuthMode()">Нет аккаунта? Зарегистрироваться</div>
        </div>
    </div>

    <div id="screen-main" class="menu-screen">
        <h1>MINECRAFT JS</h1>
        <div style="color: #aaa; margin-bottom: 20px;">Привет, <span id="user-display-name" style="color:white; font-weight:bold;">Игрок</span>!</div>
        
        <button class="mc-btn" onclick="showScreen('screen-worlds')">Одиночная игра</button>
        <button class="mc-btn" onclick="showScreen('screen-multi')">Сетевая игра</button>
        <button class="mc-btn" onclick="showScreen('screen-settings')">Настройки</button>
        <button class="mc-btn" onclick="logout()" style="background: #533; margin-top: 20px;">Выйти из аккаунта</button>
    </div>

    <div id="screen-multi" class="menu-screen">
        <h1>Сетевая игра</h1>
        <h2 style="color: #aaa; font-size: 14px; margin: 0;">Мои облачные сервера:</h2>
        <div id="server-list"></div>

        <button class="mc-btn" onclick="createLobby()">Создать новый сервер</button>
        <h2 style="margin: 5px; font-size: 14px;">--- Подключиться к другу ---</h2>
        <input type="text" id="lobby-code-input" class="mc-input" placeholder="Код лобби (4 цифры)" maxlength="10">
        <button class="mc-btn" onclick="joinLobby()">Подключиться</button>
        <button class="mc-btn" onclick="showScreen('screen-main')">Назад</button>
    </div>

    <div id="screen-worlds" class="menu-screen">
        <h1>Локальные миры</h1>
        <div id="world-list"></div>
        <input type="text" id="new-world-name" class="mc-input" placeholder="Название нового мира">
        <button class="mc-btn" onclick="createLocalWorld()">Создать</button>
        <button class="mc-btn" onclick="showScreen('screen-main')">Назад</button>
    </div>

    <div id="screen-settings" class="menu-screen">
        <h1>Настройки</h1>
        <div class="setting-row"><label>Чувствительность: <span id="sens-val">0.5</span></label><input type="range" min="0.1" max="2.0" step="0.1" value="0.5" id="sens-slider"></div>
        <div class="setting-row"><label>Прорисовка: <span id="dist-val">60</span></label><input type="range" min="20" max="100" step="10" value="60" id="dist-slider"></div>
        <button class="mc-btn" onclick="saveSettings()">Готово</button>
    </div>

    <div id="pause-menu">
        <h1>Пауза</h1>
        <button class="mc-btn" onclick="resumeGame()">Вернуться</button>
        <button class="mc-btn" onclick="openSettingsIngame()">Настройки</button>
        <button class="mc-btn" onclick="quitToTitle()">Сохранить и выйти</button>
    </div>

    <div id="game-ui">
        <div id="crosshair"></div><div id="lobby-info"></div>
        <div id="hotbar">
            <div class="slot active" id="slot-0"></div><div class="slot" id="slot-1"></div><div class="slot" id="slot-2"></div><div class="slot" id="slot-3"></div><div class="slot" id="slot-4"></div>
        </div>
        <div id="inventory-screen">
            <div id="inventory-container">
                <div style="font-weight:bold;">Блоки:</div><div class="inv-grid" id="creative-grid"></div>
                <div style="text-align: center; color: #333; margin-top: 10px;">E - закрыть</div>
            </div>
        </div>
        <div id="cursor-item"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "firebase-app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
                "firebase-database": "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js",
                "firebase-auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from "firebase-app";
        import { getDatabase, ref, set, remove, onChildAdded, onChildChanged, onChildRemoved, onDisconnect, onValue, get, query, orderByChild, equalTo } from "firebase-database";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile, onAuthStateChanged, signOut } from "firebase-auth";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
          apiKey: "AIzaSyA-ZeBBpiBMwqGVfGL9bSunUu_d2dXVgcI",
          authDomain: "minecraft-2ec53.firebaseapp.com",
          projectId: "minecraft-2ec53",
          storageBucket: "minecraft-2ec53.firebasestorage.app",
          messagingSenderId: "1065608540888",
          appId: "1:1065608540888:web:6d0a253399e3f6ff94ddad"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // --- AUTH & ANTI-CHEAT ---
        let isRegisterMode = false;
        let currentUser = null;
        let statusRef = null;

        window.toggleAuthMode = () => {
            isRegisterMode = !isRegisterMode;
            document.getElementById('auth-title').innerText = isRegisterMode ? "РЕГИСТРАЦИЯ" : "ВХОД";
            document.getElementById('btn-auth-action').innerText = isRegisterMode ? "СОЗДАТЬ АККАУНТ" : "ВОЙТИ";
            document.getElementById('auth-toggle').innerText = isRegisterMode ? "Уже есть аккаунт? Войти" : "Нет аккаунта? Зарегистрироваться";
            document.getElementById('auth-nick').style.display = isRegisterMode ? "block" : "none";
            document.getElementById('auth-error').style.display = 'none';
        };

        window.handleAuth = () => {
            const email = document.getElementById('auth-email').value;
            const pass = document.getElementById('auth-pass').value;
            const nick = document.getElementById('auth-nick').value;
            const errBox = document.getElementById('auth-error');

            if (!email || !pass) { errBox.style.display='block'; errBox.innerText = "Заполните поля"; return; }

            if (isRegisterMode) {
                if(!nick) { errBox.style.display='block'; errBox.innerText = "Нужен никнейм"; return; }
                createUserWithEmailAndPassword(auth, email, pass)
                    .then((uc) => { updateProfile(uc.user, { displayName: nick }); })
                    .catch((error) => { errBox.style.display='block'; errBox.innerText = error.message; });
            } else {
                signInWithEmailAndPassword(auth, email, pass)
                    .catch((error) => { errBox.style.display='block'; errBox.innerText = "Неверный логин или пароль"; });
            }
        };

        window.logout = () => {
            // Перед выходом ставим статус offline
            if (statusRef) set(statusRef, { state: 'offline' }).then(() => signOut(auth));
            else signOut(auth);
            
            showScreen('screen-auth');
        };

        // --- AUTH STATE & PRESENCE SYSTEM ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                // ПРОВЕРКА ДВОЙНОГО ВХОДА
                const userStatusRef = ref(db, `status/${user.uid}`);
                
                get(userStatusRef).then((snapshot) => {
                    const status = snapshot.val();
                    
                    // Если в базе написано, что мы УЖЕ онлайн
                    if (status && status.state === 'online') {
                        // Показываем экран блокировки
                        showScreen('screen-blocked');
                        // И сразу разлогиниваем
                        signOut(auth);
                    } else {
                        // Все ок, заходим
                        currentUser = user;
                        statusRef = userStatusRef;
                        
                        // 1. Ставим статус Online
                        set(statusRef, { state: 'online', last_login: Date.now() });
                        
                        // 2. Ставим мину (если интернет пропадет - станет offline)
                        onDisconnect(statusRef).set({ state: 'offline', last_seen: Date.now() });

                        document.getElementById('user-display-name').innerText = user.displayName || "Игрок";
                        showScreen('screen-main');
                    }
                });

            } else {
                currentUser = null;
                showScreen('screen-auth');
            }
        });

        // Если закрываем вкладку - тоже пытаемся поставить offline (для надежности)
        window.addEventListener("beforeunload", function() {
            if (statusRef) set(statusRef, { state: 'offline' });
        });

        // --- GLOBAL VARS ---
        let camera, scene, renderer, controls;
        const objects = []; let worldData = {}; const objectsMap = {}; const otherPlayers = {}; let raycaster;
        let isMultiplayer = false, isHost = false, currentLobbyId = null, currentWorldName = null;
        let isPaused = false, isGameRunning = false;
        let playerRef, worldRef, lobbyRefCheck;
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, canJump=false, isSprinting=false, isCrouching=false;
        const velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let prevTime = performance.now(), lastUploadTime = 0;
        let settings = { sensitivity: 0.5, renderDist: 60 };
        let isInventoryOpen = false, holdingBlockIndex = null, hotbarContent = [null,null,null,null,null], selectedSlot = 0;
        const WALK_SPEED=30.0, SPRINT_SPEED=50.0, CROUCH_SPEED=10.0, JUMP_FORCE=9, GRAVITY=24.0;
        const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
        let materials = [];
        const textureUrls = ['./textures/grass.png', './textures/dirt.png', './textures/bricks.png', './textures/obsidian.png', './textures/iron.png'];

        // --- MENUS ---
        window.showScreen = (screenId) => {
            document.querySelectorAll('.menu-screen').forEach(el => el.style.display = 'none');
            document.getElementById(screenId).style.display = 'flex';
            if (screenId === 'screen-worlds') renderWorldList();
            if (screenId === 'screen-multi') fetchMyServers();
        };

        const sS = document.getElementById('sens-slider'), dS = document.getElementById('dist-slider');
        sS.oninput=()=>document.getElementById('sens-val').innerText=sS.value; dS.oninput=()=>document.getElementById('dist-val').innerText=dS.value;
        window.saveSettings = () => {
            settings.sensitivity = parseFloat(sS.value); settings.renderDist = parseInt(dS.value);
            if(controls) controls.pointerSpeed = settings.sensitivity;
            if(isGameRunning) { document.getElementById('screen-settings').style.display='none'; document.getElementById('pause-menu').style.display='flex'; } else showScreen('screen-main');
        };
        window.openSettingsIngame = () => { document.getElementById('pause-menu').style.display='none'; document.getElementById('screen-settings').style.display='flex'; };

        // --- LOCAL WORLDS ---
        function getLocalWorlds() { return JSON.parse(localStorage.getItem('mc_worlds') || '{}'); }
        function saveLocalWorlds(w) { try{localStorage.setItem('mc_worlds', JSON.stringify(w))}catch(e){} }
        window.createLocalWorld = () => { const n = document.getElementById('new-world-name').value.trim(); if(!n)return; const w=getLocalWorlds(); if(w[n])return alert("Занято"); w[n]={blocks:{}}; saveLocalWorlds(w); loadLocalWorld(n); };
        window.renderWorldList = () => {
            const l = document.getElementById('world-list'); l.innerHTML=''; const w=getLocalWorlds();
            for(let n in w) {
                const d=document.createElement('div'); d.className='list-item'; d.innerHTML=`<span>${n}</span><span class="del-btn" onclick="deleteWorld('${n}')">УДАЛИТЬ</span>`;
                d.onclick=(e)=>{if(!e.target.classList.contains('del-btn')) loadLocalWorld(n)}; l.appendChild(d);
            }
        };
        window.deleteWorld=(n)=>{if(confirm("Удалить?")){const w=getLocalWorlds();delete w[n];saveLocalWorlds(w);renderWorldList();}};
        function loadLocalWorld(n){ currentWorldName=n; isMultiplayer=false; isHost=false; startEngine(); const w=getLocalWorlds()[n].blocks; if(Object.keys(w).length>0) for(let k in w){const[x,y,z]=k.split(',').map(Number);createBlock(x,y,z,materials[w[k]],false);} else generateBasicTerrain(); }

        // --- CLOUD SERVERS ---
        window.fetchMyServers = () => {
            if (!currentUser) return;
            const l = document.getElementById('server-list'); l.innerHTML = 'Загрузка...';
            const myLobbiesQuery = query(ref(db, 'lobbies'), orderByChild('ownerId'), equalTo(currentUser.uid));
            onValue(myLobbiesQuery, (snapshot) => {
                l.innerHTML = '';
                if (!snapshot.exists()) { l.innerHTML = '<div style="padding:10px; color:#aaa;">Нет активных серверов</div>'; return; }
                snapshot.forEach((childSnap) => {
                    const code = childSnap.key;
                    const d = document.createElement('div'); d.className = 'list-item';
                    d.innerHTML = `<span>Сервер: ${code} <span class="status-active">● Онлайн</span></span> <span class="del-btn" onclick="killServer('${code}')">ВЫКЛЮЧИТЬ</span>`;
                    d.onclick = (e) => { if(!e.target.classList.contains('del-btn')) { document.getElementById('lobby-code-input').value = code; } };
                    l.appendChild(d);
                });
            }, { onlyOnce: false });
        };

        window.createLobby = () => {
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            isHost = true;
            set(ref(db, `lobbies/${code}`), { ownerId: currentUser.uid, created: Date.now(), world: {}, players: {} }).then(() => { startMultiplayer(code); });
        };
        window.killServer = (code) => { if(!confirm("Удалить сервер?")) return; remove(ref(db, `lobbies/${code}`)); };
        window.joinLobby = () => {
            const code = document.getElementById('lobby-code-input').value; if(!code) return alert("Введите код");
            get(ref(db, `lobbies/${code}`)).then(snapshot => {
                if (snapshot.exists()) { isHost = (snapshot.val().ownerId === currentUser.uid); startMultiplayer(code); } else alert("Сервер не найден!");
            });
        };

        function startMultiplayer(code) {
            isMultiplayer = true; currentLobbyId = code; currentWorldName = null; startEngine();
            document.getElementById('lobby-info').style.display = 'block'; document.getElementById('lobby-info').innerText = isHost ? `Сервер: ${code} (HOST)` : `Сервер: ${code}`;
            lobbyRefCheck = onValue(ref(db, `lobbies/${currentLobbyId}`), (snap) => { if (!snap.exists()) quitToTitle(true, "СЕРВЕР БЫЛ ВЫКЛЮЧЕН ВЛАДЕЛЬЦЕМ"); });
            playerRef = ref(db, `lobbies/${currentLobbyId}/players/${currentUser.uid}`);
            onDisconnect(playerRef).remove();
            set(playerRef, { x: 0, y: 20, z: 0, rotation: 0, nick: currentUser.displayName });
            
            const pRef = ref(db, `lobbies/${currentLobbyId}/players`);
            onChildAdded(pRef, (s) => { if(s.key !== currentUser.uid) createOtherPlayer(s.key, s.val()); });
            onChildChanged(pRef, (s) => { if(s.key !== currentUser.uid && otherPlayers[s.key]) updateOtherPlayer(s.key, s.val()); });
            onChildRemoved(pRef, (s) => { if(otherPlayers[s.key]) { scene.remove(otherPlayers[s.key].mesh); delete otherPlayers[s.key]; } });
            
            worldRef = ref(db, `lobbies/${currentLobbyId}/world`);
            onChildAdded(worldRef, (s) => { const [x,y,z] = s.key.split('_').map(Number); if (!hasBlock(x,y,z)) createBlock(x,y,z,materials[s.val()], true); });
            onChildRemoved(worldRef, (s) => { const [x,y,z] = s.key.split('_').map(Number); const mesh = objectsMap[`${x},${y},${z}`]; if(mesh) removeBlockLocal(mesh); });
            setTimeout(() => { if (Object.keys(worldData).length === 0) generateBasicTerrain(); }, 1000);
        }

        // --- ENGINE ---
        function startEngine() {
            document.querySelectorAll('.menu-screen').forEach(el => el.style.display = 'none'); document.getElementById('game-ui').style.display = 'block';
            init(); controls.pointerSpeed = settings.sensitivity; scene.fog.far = settings.renderDist; camera.far = settings.renderDist*2;
            isGameRunning = true; isPaused = false; animate(); setTimeout(() => { alert("Готово! Кликни для старта."); }, 100);
        }
        window.resumeGame = () => { document.getElementById('pause-menu').style.display='none'; controls.lock(); };
        window.quitToTitle = (forced=false, msg="") => {
            if (lobbyRefCheck) lobbyRefCheck();
            if (isMultiplayer && !forced) remove(playerRef);
            if (!isMultiplayer && currentWorldName && !forced) {
                const w = getLocalWorlds(); const b = {};
                for(let k in worldData) { if(objectsMap[k]) b[k] = materials.indexOf(objectsMap[k].material); }
                w[currentWorldName].blocks = b; saveLocalWorlds(w);
            }
            if(forced) alert(msg); location.reload();
        };

        function generateBasicTerrain() {
            const R=12; for(let y=-5; y<0; y++) for(let x=-R; x<R; x++) for(let z=-R; z<R; z++) createBlock(x,y,z,materials[1]);
            for(let x=-R; x<R; x++) for(let z=-R; z<R; z++) createBlock(x,0,z,materials[0]);
        }

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 10, 60);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.005, 1000); camera.position.set(0,15,0);
            scene.add(new THREE.AmbientLight(0xcccccc)); const d=new THREE.DirectionalLight(0xffffff,0.6); d.position.set(10,20,10); scene.add(d);
            controls = new PointerLockControls(camera, document.body);
            controls.addEventListener('lock', ()=>{isPaused=false; document.getElementById('pause-menu').style.display='none'; isInventoryOpen=false; document.getElementById('inventory-screen').style.display='none';});
            controls.addEventListener('unlock', ()=>{if(isInventoryOpen)return; isPaused=true; document.getElementById('pause-menu').style.display='flex';});
            document.addEventListener('click', (e)=>{if(!isGameRunning||isPaused||isInventoryOpen)return; if(e.target.closest('.mc-btn')||e.target.closest('#pause-menu'))return; controls.lock();});
            const l=new THREE.TextureLoader(); const f=new THREE.MeshBasicMaterial({color:0xff00ff});
            try { materials = textureUrls.map(u => new THREE.MeshLambertMaterial({ map: l.load(u, t=>{t.magFilter=THREE.NearestFilter}) })); initInv(); updateHotbar(); } catch(e){materials=[f]}
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); document.addEventListener('wheel', onWheel); document.addEventListener('mousemove', onMM); document.addEventListener('mousedown', onMC);
            raycaster=new THREE.Raycaster(); raycaster.far=5;
            renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); window.addEventListener('resize', onRez);
        }

        function onKeyDown(e) {
            if(!isGameRunning)return;
            if(e.code==='KeyE'){ if(isPaused)return; if(isInventoryOpen){isInventoryOpen=false;document.getElementById('inventory-screen').style.display='none';controls.lock();}else{isInventoryOpen=true;document.getElementById('inventory-screen').style.display='flex';controls.unlock();} return; }
            if(e.code==='KeyW')moveForward=true; if(e.code==='KeyA')moveLeft=true; if(e.code==='KeyS')moveBackward=true; if(e.code==='KeyD')moveRight=true;
            if(e.code==='Space'){if(canJump&&!isCrouching){velocity.y+=JUMP_FORCE;canJump=false;}} if(e.code==='ControlLeft')isSprinting=true; if(e.code==='ShiftLeft')isCrouching=true;
            if(e.code.startsWith('Digit')){const n=parseInt(e.code.slice(5))-1; if(n>=0&&n<5)selectSlot(n);}
        }
        function onKeyUp(e){ if(e.code==='KeyW')moveForward=false;if(e.code==='KeyA')moveLeft=false;if(e.code==='KeyS')moveBackward=false;if(e.code==='KeyD')moveRight=false;if(e.code==='ControlLeft')isSprinting=false;if(e.code==='ShiftLeft')isCrouching=false; }
        function onWheel(e){ if(isPaused||isInventoryOpen)return; if(e.deltaY>0){let s=selectedSlot+1;if(s>4)s=0;selectSlot(s);}else{let s=selectedSlot-1;if(s<0)s=4;selectSlot(s);} }
        function initInv(){const g=document.getElementById('creative-grid');g.innerHTML='';textureUrls.forEach((u,i)=>{const d=document.createElement('div');d.className='inv-slot';d.style.backgroundImage=`url(${u})`;d.onclick=()=>{holdingBlockIndex=i;updCur(u)};g.appendChild(d)}); for(let i=0;i<5;i++)document.getElementById(`slot-${i}`).onclick=()=>{if(isInventoryOpen&&holdingBlockIndex!==null){hotbarContent[i]=holdingBlockIndex;updateHotbar();holdingBlockIndex=null;updCur(null)}};}
        function updCur(u){const c=document.getElementById('cursor-item');if(u){c.style.display='block';c.style.backgroundImage=`url(${u})`;}else c.style.display='none';}
        function updateHotbar(){for(let i=0;i<5;i++){const s=document.getElementById(`slot-${i}`);s.style.backgroundImage=hotbarContent[i]!==null?`url(${textureUrls[hotbarContent[i]]})`:'none';}}
        function onMM(e){if(isInventoryOpen&&holdingBlockIndex!==null){const c=document.getElementById('cursor-item');c.style.left=e.clientX+'px';c.style.top=e.clientY+'px';}}
        function selectSlot(i){selectedSlot=i;document.querySelectorAll('.slot').forEach(e=>e.classList.remove('active'));document.getElementById(`slot-${i}`).classList.add('active');}
        function onRez(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);}

        function createBlock(x,y,z,m,net=false) { const o=new THREE.Mesh(cubeGeo,m); o.position.set(x,y,z); scene.add(o); objects.push(o); const k=`${x},${y},${z}`; worldData[k]=true; objectsMap[k]=o; if(isMultiplayer&&!net) set(ref(db, `lobbies/${currentLobbyId}/world/${x}_${y}_${z}`), materials.indexOf(m)); }
        function removeBlockLocal(o) { scene.remove(o); objects.splice(objects.indexOf(o),1); const k=`${Math.round(o.position.x)},${Math.round(o.position.y)},${Math.round(o.position.z)}`; delete worldData[k]; delete objectsMap[k]; }
        function onMC(e) {
            if(isPaused||isInventoryOpen||!controls.isLocked)return;
            raycaster.setFromCamera(new THREE.Vector2(0,0),camera); const i=raycaster.intersectObjects(objects);
            if(i.length>0 && i[0].distance<=5) {
                if(e.button===0) { removeBlockLocal(i[0].object); if(isMultiplayer) remove(ref(db,`lobbies/${currentLobbyId}/world/${Math.round(i[0].object.position.x)}_${Math.round(i[0].object.position.y)}_${Math.round(i[0].object.position.z)}`)); }
                else if(e.button===2) { const m=hotbarContent[selectedSlot]; if(m===null)return; const p=i[0].object.position.clone().add(i[0].face.normal); 
                if(Math.abs(camera.position.x-p.x)<0.7 && Math.abs(camera.position.z-p.z)<0.7 && camera.position.y-1.6<p.y+0.3) return; createBlock(p.x,p.y,p.z,materials[m]); }
            }
        }
        function checkCol(nx,nz){const r=0.3,yf=Math.floor(camera.position.y-1.1),yh=Math.floor(camera.position.y-0.1); const k=[`${Math.round(nx+r)},${yf},${Math.round(nz+r)}`,`${Math.round(nx-r)},${yf},${Math.round(nz-r)}`]; return k.some(key=>worldData[key]);} 
        function checkG(x,y,z){const by=Math.round(y-0.5); return worldData[`${Math.round(x)},${by},${Math.round(z)}`];} 

        function createOtherPlayer(id, data) {
            const g=new THREE.BoxGeometry(0.6,1.8,0.6); const m=new THREE.MeshLambertMaterial({color:0xff0000}); const mesh=new THREE.Mesh(g,m);
            const hg=new THREE.BoxGeometry(0.4,0.4,0.4); const hm=new THREE.MeshLambertMaterial({color:0xffccaa}); const head=new THREE.Mesh(hg,hm); head.position.y=0.9; mesh.add(head);
            if (data.nick) {
                const c=document.createElement('canvas'); const ctx=c.getContext('2d'); c.width=256; c.height=64;
                ctx.fillStyle="rgba(0,0,0,0.5)"; ctx.fillRect(0,0,256,64); ctx.fillStyle="white"; ctx.font="30px Arial"; ctx.textAlign="center"; ctx.fillText(data.nick,128,42);
                const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c)})); s.position.y=1.6; s.scale.set(2,0.5,1); mesh.add(s);
            }
            mesh.position.set(data.x,data.y-0.9,data.z); scene.add(mesh); otherPlayers[id]={mesh};
        }
        function updateOtherPlayer(id,data){const p=otherPlayers[id]; p.mesh.position.set(data.x,data.y-0.9,data.z); p.mesh.rotation.y=data.rotation;}
        
        function animate() {
            requestAnimationFrame(animate); if(!isGameRunning)return;
            const t=performance.now(), d=Math.min((t-prevTime)/1000,0.05);
            let sim=false; if(isMultiplayer)sim=true; else if(!isPaused&&!isInventoryOpen&&controls.isLocked)sim=true;
            if(sim) {
                velocity.x-=velocity.x*10.0*d; velocity.z-=velocity.z*10.0*d; velocity.y-=GRAVITY*d;
                if((isMultiplayer&&controls.isLocked&&!isInventoryOpen)||(!isMultiplayer&&sim)) {
                    direction.z=Number(moveForward)-Number(moveBackward); direction.x=Number(moveRight)-Number(moveLeft); direction.normalize();
                    let spd=isCrouching?CROUCH_SPEED:(isSprinting?SPRINT_SPEED:WALK_SPEED);
                    if(moveForward||moveBackward)velocity.z-=direction.z*spd*d; if(moveLeft||moveRight)velocity.x-=direction.x*spd*d;
                }
                controls.moveRight(-velocity.x*d); controls.moveForward(-velocity.z*d);
                camera.position.y += velocity.y*d; 
                if(camera.position.y < -30) { camera.position.set(0,20,0); velocity.y=0; }
                const feet = camera.position.y - 1.6;
                if (checkG(camera.position.x, feet, camera.position.z) && velocity.y < 0) { camera.position.y = Math.round(feet-0.5)+0.5+1.6; velocity.y=0; canJump=true; }
                if(isMultiplayer && t-lastUploadTime>150) { if(playerRef)set(playerRef,{x:camera.position.x,y:camera.position.y,z:camera.position.z,rotation:camera.rotation.y, nick:currentUser.displayName}); lastUploadTime=t; }
            }
            prevTime=t; renderer.render(scene, camera);
        }
    </script>
</body>
</html>
