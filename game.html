<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Minecraft JS: STABLE</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; background: #000; }
        
        #game-ui { display: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; pointer-events: none; }
        #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px; z-index: 150; }
        .slot { width: 60px; height: 60px; border: 4px solid #555; background-color: rgba(0,0,0,0.4); background-size: cover; cursor: pointer; }
        .slot.active { border-color: white; transform: scale(1.1); background-color: rgba(255,255,255,0.1); }
        #info-panel { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none; font-weight: bold; }

        .overlay-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
        .mc-btn { width: 300px; padding: 15px; margin: 10px; font-size: 20px; color: #ddd; background: #777; border: 4px solid #555; cursor: pointer; text-shadow: 2px 2px #000; }
        .mc-btn:hover { background: #888; color: white; border-color: #777; }
        
        .inv-grid { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 400px; }
        .inv-slot { width: 50px; height: 50px; border: 2px solid #888; background: #8b8b8b; cursor: pointer; background-size: cover; }
        #cursor-item { position: absolute; width: 40px; height: 40px; pointer-events: none; z-index: 200; background-size: cover; display: none; border: 2px solid yellow; }

        #screen-error { 
            display: flex; 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: url('./textures/dirt.png'); 
            z-index: 9999; 
            flex-direction: column; align-items: center; justify-content: center; 
            text-align: center;
        }
        #screen-error::before {
            content: ""; position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.75); z-index: -1;
        }
        .err-title { font-size: 26px; color: #ffffff; margin-bottom: 20px; font-weight: bold; text-shadow: 2px 2px #333; }
        .err-desc { font-size: 18px; color: #aaaaaa; margin-bottom: 40px; max-width: 600px; line-height: 1.5; text-shadow: 1px 1px #222; }
        #btn-menu { display: none; }
    </style>
</head>
<body>

    <div id="game-ui">
        <div id="crosshair"></div>
        <div id="info-panel">Инициализация...</div>
        <div id="hotbar"><div class="slot active" id="slot-0"></div><div class="slot" id="slot-1"></div><div class="slot" id="slot-2"></div><div class="slot" id="slot-3"></div><div class="slot" id="slot-4"></div></div>
    </div>

    <div id="pause-menu" class="overlay-menu">
        <h1 style="color:white; font-size:40px; text-shadow:2px 2px #000;">ПАУЗА</h1>
        <button class="mc-btn" onclick="resume()">ВЕРНУТЬСЯ</button>
        <button class="mc-btn" onclick="quit(false)">СОХРАНИТЬ И ВЫЙТИ</button>
    </div>

    <div id="inventory-screen" class="overlay-menu">
        <h2 style="color:white; text-shadow:2px 2px #000;">БЛОКИ</h2>
        <div class="inv-grid" id="creative-grid"></div>
        <div style="color:#aaa; margin-top:20px;">E - Закрыть</div>
    </div>
    <div id="cursor-item"></div>

    <div id="screen-error">
        <div class="err-title" id="err-header">ЗАГРУЗКА...</div>
        <div class="err-desc" id="err-msg">Проверка профиля</div>
        <button id="btn-menu" class="mc-btn" onclick="location.href='index.html'">В МЕНЮ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "firebase-app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
                "firebase-database": "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js",
                "firebase-auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from "firebase-app";
        import { getDatabase, ref, set, update, remove, onChildAdded, onChildChanged, onChildRemoved, onDisconnect, onValue, get } from "firebase-database";
        import { getAuth, onAuthStateChanged } from "firebase-auth";

        const MODE = localStorage.getItem('mc_mode'); 
        const WORLD_NAME = localStorage.getItem('mc_current_world');
        const LOBBY_ID = localStorage.getItem('mc_lobby_id');
        const IS_HOST = (localStorage.getItem('mc_is_host') === 'true');
        const SETTINGS = JSON.parse(localStorage.getItem('mc_settings') || '{"sens":0.5, "dist":60}');
        
        const app = initializeApp({ apiKey: "AIzaSyA-ZeBBpiBMwqGVfGL9bSunUu_d2dXVgcI", authDomain: "minecraft-2ec53.firebaseapp.com", projectId: "minecraft-2ec53", storageBucket: "minecraft-2ec53.firebasestorage.app", messagingSenderId: "1065608540888", appId: "1:1065608540888:web:6d0a253399e3f6ff94ddad" });
        const db = getDatabase(app);
        const auth = getAuth(app);
        let currentUser = null, playerRef = null, statusRef = null;

        let camera, scene, renderer, controls = null;
        const objects = []; let worldData = {}; const objectsMap = {}; const otherPlayers = {}; let raycaster;
        let isPaused = false, isGameRunning = false, isInvOpen = false;
        let moveF=0, moveB=0, moveL=0, moveR=0, canJump=false, isSprint=false, isCrouch=false;
        const velocity = new THREE.Vector3();
        let prevTime = performance.now(), lastUploadTime = 0;
        
        // --- ФИКС ФИЗИКИ: P_W (ширина игрока) уменьшена с 0.9 до 0.7 ---
        const WALK=5.0, SPRINT=8.0, CROUCH=3.0, JUMP=9, GRAVITY=24.0, P_W=0.7, P_H=1.8, EYE=1.6;
        const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
        let materials = [];
        
        const texUrls = [
            './textures/grass.png', './textures/dirt.png', './textures/stone.png', 
            './textures/obsidian.png', './textures/iron.png', './textures/log.png', 
            './textures/planks.png', './textures/brick.png', './textures/sand.png', 
            './textures/diamond.png'
        ];
        
        let hotbar = [null,null,null,null,null], selSlot=0, holdBlock=null;

        if(MODE === 'multi') {
            onAuthStateChanged(auth, user => {
                if(user) {
                    currentUser = user;
                    get(ref(db, `lobbies/${LOBBY_ID}/banned/${currentUser.uid}`)).then(snap => {
                        if(snap.exists()) showDisconnectScreen("Вы забанены", `Причина: ${snap.val().reason}`);
                        else checkAntiCheatAndStart();
                    }).catch(err => showDisconnectScreen("Ошибка", "Нет связи"));
                } else { window.location.href = 'index.html'; }
            });
        } else {
            hideLoadingScreen();
            startEngine();
            loadLocalWorld();
        }

        function checkAntiCheatAndStart() {
            const sRef = ref(db, `status/${currentUser.uid}`);
            get(sRef).then(snap => {
                const s = snap.val();
                if(s && s.state === 'online' && (Date.now() - s.last_seen < 15000)) {
                    showDisconnectScreen("Ошибка входа", "Двойной вход в аккаунт");
                } else {
                    statusRef = sRef;
                    set(statusRef, {state: 'online', last_seen: Date.now()});
                    onDisconnect(statusRef).set({state: 'offline'});
                    setInterval(() => set(ref(db, `status/${currentUser.uid}/last_seen`), Date.now()), 5000);
                    hideLoadingScreen();
                    startEngine();
                    connectToLobby();
                }
            });
        }

        function connectToLobby() {
            document.getElementById('info-panel').innerText = `Сервер: ${LOBBY_ID}`;
            genTerrain();

            onValue(ref(db, `lobbies/${LOBBY_ID}`), s => { 
                if(!s.exists()) quit(true, "Сервер удален", "Хост удалил этот мир"); 
                else if(s.val().status === 'offline' && !IS_HOST) quit(true, "Сервер остановлен", "Хост выключил сервер");
            });

            playerRef = ref(db, `lobbies/${LOBBY_ID}/players/${currentUser.uid}`);
            onDisconnect(playerRef).remove();
            set(playerRef, { x:0, y:20, z:0, rotation:0, nick: currentUser.displayName });

            onValue(playerRef, snap => {
                if(isGameRunning && snap.exists()) {
                    const data = snap.val();
                    if (data._forceKick) quit(true, "ВАС КИКНУЛИ", "Вы были отключены от сервера");
                    if (data._forceBan) {
                         get(ref(db, `lobbies/${LOBBY_ID}/banned/${currentUser.uid}`)).then(bSnap => {
                            const r = bSnap.exists() ? bSnap.val().reason : "Бан";
                            quit(true, "ВЫ ЗАБАНЕНЫ", `Причина: ${r}`);
                         });
                    }
                }
                if(isGameRunning && !snap.exists()) quit(true, "Отключено", "Потеряна связь с профилем");
            });

            const pRef = ref(db, `lobbies/${LOBBY_ID}/players`);
            onChildAdded(pRef, s => { if(s.key !== currentUser.uid) spawnPlayer(s.key, s.val()); });
            onChildChanged(pRef, s => { if(s.key !== currentUser.uid && otherPlayers[s.key]) movePlayer(s.key, s.val()); });
            onChildRemoved(pRef, s => { if(otherPlayers[s.key]) { scene.remove(otherPlayers[s.key].mesh); delete otherPlayers[s.key]; } });

            // --- ИСПРАВЛЕННАЯ СИНХРОНИЗАЦИЯ ПОЛА ---
            const wRef = ref(db, `lobbies/${LOBBY_ID}/world`);
            const handleUpdate = (snap) => {
                const [x,y,z] = snap.key.split('_').map(Number);
                const val = snap.val();
                
                // Сначала ВСЕГДА удаляем то, что там есть (даже если это трава)
                const existing = objectsMap[`${x},${y},${z}`];
                if (existing) removeBlockLocal(existing);

                // Если это не "99" (пустота/сломано), то ставим новый блок
                if (val !== 99) { 
                    createBlock(x,y,z, materials[val], true, false); 
                }
            };
            onChildAdded(wRef, handleUpdate);
            onChildChanged(wRef, handleUpdate);
        }

        function hideLoadingScreen() {
            document.getElementById('screen-error').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
        }

        function showDisconnectScreen(title, msg) {
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('pause-menu').style.display = 'none';
            if(renderer) renderer.domElement.style.display = 'none';
            const screen = document.getElementById('screen-error');
            document.getElementById('err-header').innerText = title;
            document.getElementById('err-msg').innerText = msg;
            document.getElementById('btn-menu').style.display = 'block';
            screen.style.display = 'flex';
        }

        window.quit = (forced, title, msg) => {
            isGameRunning = false; 
            if(controls) controls.unlock();
            if(MODE === 'single' && !forced) saveLocalWorld();
            if(MODE === 'multi' && playerRef && !forced) remove(playerRef);
            if(statusRef) set(statusRef, {state: 'offline'}); 
            if(forced) showDisconnectScreen(title, msg);
            else window.location.href = 'index.html';
        };
        
        window.resume = () => { if(controls) { document.getElementById('pause-menu').style.display='none'; controls.lock(); } };

        function startEngine() { init3D(); isGameRunning = true; animate(); }

        function init3D() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 10, SETTINGS.dist);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.005, SETTINGS.dist * 2); camera.position.set(0, 15, 0);
            scene.add(new THREE.AmbientLight(0xcccccc)); 
            const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(10,20,10); scene.add(dl);
            controls = new PointerLockControls(camera, document.body); controls.pointerSpeed = SETTINGS.sens;
            
            controls.addEventListener('lock', () => { 
                isPaused=false; document.getElementById('pause-menu').style.display='none'; 
                isInvOpen=false; document.getElementById('inventory-screen').style.display='none'; 
            });
            controls.addEventListener('unlock', () => { 
                if(isInvOpen || !isGameRunning) return; 
                isPaused=true; document.getElementById('pause-menu').style.display='flex'; 
            });
            
            const l = new THREE.TextureLoader();
            try { materials = texUrls.map(u => new THREE.MeshLambertMaterial({ map: l.load(u, t=>{t.magFilter=THREE.NearestFilter}) })); } catch(e){}
            initUI();
            
            document.addEventListener('keydown', onKey); document.addEventListener('keyup', onKey);
            document.addEventListener('wheel', onWheel); document.addEventListener('mousedown', onClick);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('click', () => { if(isGameRunning && !isPaused && !isInvOpen && controls) controls.lock(); });
            
            raycaster = new THREE.Raycaster(); raycaster.far = 5;
            renderer = new THREE.WebGLRenderer({antialias: true}); renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });
        }

        function genTerrain() {
            const R = 12;
            for(let x=-R; x<R; x++) for(let z=-R; z<R; z++) {
                createBlock(x, 0, z, materials[0], false, true);
                for(let y=-1; y>=-4; y--) createBlock(x, y, z, materials[1], false, true);
                for(let y=-5; y>=-9; y--) createBlock(x, y, z, materials[2], false, true);
                createBlock(x, -10, z, materials[3], false, true);
            }
        }

        function getKey(x,y,z){return `${x},${y},${z}`;}
        function hasBlock(x,y,z){return worldData[getKey(Math.round(x),Math.round(y),Math.round(z))];}
        function createBlock(x,y,z,m,net=false, isGen=false) {
            const o = new THREE.Mesh(cubeGeo, m); o.position.set(x,y,z); scene.add(o); objects.push(o);
            const k = getKey(x,y,z); worldData[k]=true; objectsMap[k]=o;
            if(MODE === 'multi' && !net && !isGen) set(ref(db, `lobbies/${LOBBY_ID}/world/${x}_${y}_${z}`), materials.indexOf(m));
        }
        function removeBlockLocal(o) {
            scene.remove(o); objects.splice(objects.indexOf(o),1);
            const k = getKey(Math.round(o.position.x), Math.round(o.position.y), Math.round(o.position.z));
            delete worldData[k]; delete objectsMap[k];
        }

        function onClick(e) {
            if(isPaused || isInvOpen || !controls || !controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const i = raycaster.intersectObjects(objects);
            if(i.length > 0 && i[0].distance <= 5) {
                if(e.button === 0) {
                    const obj = i[0].object;
                    const x = Math.round(obj.position.x), y = Math.round(obj.position.y), z = Math.round(obj.position.z);
                    removeBlockLocal(obj);
                    if(MODE === 'multi') {
                        // Если ломаем - ставим 99
                        set(ref(db, `lobbies/${LOBBY_ID}/world/${x}_${y}_${z}`), 99);
                    }
                } else if(e.button === 2) {
                    const m = hotbar[selSlot]; if(m===null) return;
                    const p = i[0].object.position.clone().add(i[0].face.normal);
                    if(Math.abs(camera.position.x - p.x) < 0.8 && Math.abs(camera.position.z - p.z) < 0.8 && (camera.position.y - EYE) < (p.y + 0.5)) return;
                    createBlock(p.x, p.y, p.z, materials[m]);
                }
            }
        }

        function spawnPlayer(id, data) {
            const g = new THREE.BoxGeometry(0.6, 1.8, 0.6); const m = new THREE.MeshLambertMaterial({color:0xff0000});
            const mesh = new THREE.Mesh(g, m);
            if(data.nick) {
                const c=document.createElement('canvas'); const x=c.getContext('2d'); c.width=256;c.height=64;
                x.fillStyle="rgba(0,0,0,0.5)"; x.fillRect(0,0,256,64); x.fillStyle="white"; x.font="30px Arial"; x.textAlign="center"; x.fillText(data.nick,128,42);
                const s = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c)})); s.position.y=1.6; s.scale.set(2,0.5,1); mesh.add(s);
            }
            mesh.position.set(data.x, data.y-0.9, data.z); 
            scene.add(mesh); 
            otherPlayers[id] = { mesh: mesh, targetPos: new THREE.Vector3(data.x, data.y-0.9, data.z), targetRot: data.rotation };
        }
        function movePlayer(id, data) {
            if(otherPlayers[id]) { otherPlayers[id].targetPos.set(data.x, data.y-0.9, data.z); otherPlayers[id].targetRot = data.rotation; }
        }

        function onKey(e) {
            const down = e.type === 'keydown';
            if(e.code === 'KeyW') moveF = down; if(e.code === 'KeyS') moveB = down;
            if(e.code === 'KeyA') moveL = down; if(e.code === 'KeyD') moveR = down;
            if(e.code === 'Space') if(down && canJump && !isCrouch) { velocity.y += JUMP; canJump = false; }
            if(e.code === 'ControlLeft') isSprint = down; if(e.code === 'ShiftLeft') isCrouch = down;
            if(down && e.code === 'KeyE') {
                if(isInvOpen) { isInvOpen = false; document.getElementById('inventory-screen').style.display='none'; if(controls) controls.lock(); }
                else { isInvOpen = true; document.getElementById('inventory-screen').style.display='flex'; if(controls) controls.unlock(); }
            }
            if(down && e.code.startsWith('Digit')) { const n = parseInt(e.code.slice(5))-1; if(n>=0 && n<5) selectSlot(n); }
        }

        function resolveCol(pos) {
            const r = P_W / 2; const minX = pos.x - r, maxX = pos.x + r; const minZ = pos.z - r, maxZ = pos.z + r; const minY = pos.y - EYE, maxY = pos.y + (P_H - EYE);
            for(let y = Math.round(minY); y <= Math.round(maxY); y++) {
                for(let z = Math.round(minZ); z <= Math.round(maxZ); z++) {
                    for(let x = Math.round(minX); x <= Math.round(maxX); x++) {
                        if(hasBlock(x,y,z)) { if (maxX > x-0.5 && minX < x+0.5 && maxY > y-0.5 && minY < y+0.5 && maxZ > z-0.5 && minZ < z+0.5) return true; }
                    }
                }
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate); if(!isGameRunning || isPaused) return;
            const t = performance.now(), d = Math.min((t-prevTime)/1000, 0.05);
            velocity.y -= GRAVITY * d;
            const fwd = Number(moveF) - Number(moveB); const right = Number(moveR) - Number(moveL);
            if(fwd !== 0 || right !== 0) {
                const front = new THREE.Vector3(); camera.getWorldDirection(front); front.y=0; front.normalize();
                const side = new THREE.Vector3(); side.crossVectors(front, camera.up).normalize();
                const dir = new THREE.Vector3(); dir.addScaledVector(front, fwd); dir.addScaledVector(side, right); dir.normalize();
                let s = isCrouch ? CROUCH : (isSprint ? SPRINT : WALK);
                velocity.x += dir.x * s * d * 10; velocity.z += dir.z * s * d * 10;
            }
            velocity.x -= velocity.x * 10.0 * d; velocity.z -= velocity.z * 10.0 * d;
            const pos = camera.position.clone();
            pos.x += velocity.x * d; if(resolveCol(pos)) { pos.x -= velocity.x * d; velocity.x = 0; }
            pos.z += velocity.z * d; if(resolveCol(pos)) { pos.z -= velocity.z * d; velocity.z = 0; }
            pos.y += velocity.y * d; 
            if(resolveCol(pos)) { const fall = velocity.y < 0; pos.y -= velocity.y * d; velocity.y = 0; if(fall) { canJump = true; pos.y = Math.round(pos.y - EYE - 0.5) + 0.5 + EYE; } }
            camera.position.copy(pos);
            if(camera.position.y < -30) { camera.position.set(0,30,0); velocity.y=0; }
            for (let id in otherPlayers) { const p = otherPlayers[id]; p.mesh.position.lerp(p.targetPos, 0.3); p.mesh.rotation.y += (p.targetRot - p.mesh.rotation.y) * 0.3; }
            
            if(MODE === 'multi' && t - lastUploadTime > 150) { 
                if(playerRef && isGameRunning) {
                    update(playerRef, {
                        x:camera.position.x, y:camera.position.y, z:camera.position.z, 
                        rotation:camera.rotation.y, nick:currentUser.displayName
                    }); 
                }
                lastUploadTime = t; 
            }
            prevTime = t; renderer.render(scene, camera);
        }

        function initUI() {
            const g = document.getElementById('creative-grid');
            texUrls.forEach((u,i) => { const d = document.createElement('div'); d.className='inv-slot'; d.style.backgroundImage=`url(${u})`; d.onclick = () => { holdBlock = i; updCur(u); }; g.appendChild(d); });
            for(let i=0; i<5; i++) document.getElementById(`slot-${i}`).onclick = () => { if(isInvOpen && holdBlock!==null) { hotbar[i]=holdBlock; updHot(); holdBlock=null; updCur(null); } };
        }
        function updCur(u) { const c=document.getElementById('cursor-item'); if(u){c.style.display='block';c.style.backgroundImage=`url(${u})`;}else c.style.display='none'; }
        function updHot() { for(let i=0;i<5;i++) { const s=document.getElementById(`slot-${i}`); s.style.backgroundImage = hotbar[i]!==null ? `url(${texUrls[hotbar[i]]})` : 'none'; } }
        function selectSlot(n) { selSlot=n; document.querySelectorAll('.slot').forEach(e=>e.classList.remove('active')); document.getElementById(`slot-${n}`).classList.add('active'); }
        function onWheel(e) { if(isPaused)return; if(e.deltaY>0){let s=selSlot+1;if(s>4)s=0;selectSlot(s);}else{let s=selSlot-1;if(s<0)s=4;selectSlot(s);} }
        function onMove(e) { if(isInvOpen && holdBlock!==null) { const c=document.getElementById('cursor-item'); c.style.left=e.clientX+'px'; c.style.top=e.clientY+'px'; } }
    </script>
</body>
</html>
