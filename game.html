<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Minecraft JS: MULTIPLAYER TNT</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; background: #000; }
        
        #game-ui { display: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; pointer-events: none; }
        
        #hotbar { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 5px; 
            background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px; z-index: 150; 
        }
        .slot { 
            width: 50px; height: 50px; 
            border: 3px solid #555; background-color: rgba(0,0,0,0.4); 
            background-size: cover; cursor: pointer; 
        }
        .slot.active { border-color: white; transform: scale(1.1); background-color: rgba(255,255,255,0.1); }
        
        #info-panel { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none; font-weight: bold; }

        .overlay-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; flex-direction: column; align-items: center; justify-content: center; }
        .mc-btn { width: 300px; padding: 15px; margin: 10px; font-size: 20px; color: #ddd; background: #777; border: 4px solid #555; cursor: pointer; text-shadow: 2px 2px #000; }
        .mc-btn:hover { background: #888; color: white; border-color: #777; }
        
        .inv-grid { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 500px; }
        .inv-slot { width: 50px; height: 50px; border: 2px solid #888; background: #8b8b8b; cursor: pointer; background-size: cover; }
        #cursor-item { position: absolute; width: 40px; height: 40px; pointer-events: none; z-index: 200; background-size: cover; display: none; border: 2px solid yellow; }

        #screen-error { 
            display: flex; 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: url('./textures/dirt.png'); 
            z-index: 9999; 
            flex-direction: column; align-items: center; justify-content: center; 
            text-align: center;
        }
        #screen-error::before {
            content: ""; position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.75); z-index: -1;
        }
        .err-title { font-size: 26px; color: #ffffff; margin-bottom: 20px; font-weight: bold; text-shadow: 2px 2px #333; }
        .err-desc { font-size: 18px; color: #aaaaaa; margin-bottom: 40px; max-width: 600px; line-height: 1.5; text-shadow: 1px 1px #222; }
        #btn-menu { display: none; }
    </style>
</head>
<body>

    <div id="game-ui">
        <div id="crosshair"></div>
        <div id="info-panel">Инициализация...</div>
        <div id="hotbar">
            <div class="slot active" id="slot-0"></div><div class="slot" id="slot-1"></div>
            <div class="slot" id="slot-2"></div><div class="slot" id="slot-3"></div>
            <div class="slot" id="slot-4"></div><div class="slot" id="slot-5"></div>
            <div class="slot" id="slot-6"></div><div class="slot" id="slot-7"></div>
            <div class="slot" id="slot-8"></div>
        </div>
    </div>

    <div id="pause-menu" class="overlay-menu">
        <h1 style="color:white; font-size:40px; text-shadow:2px 2px #000;">ПАУЗА</h1>
        <button class="mc-btn" onclick="resume()">ВЕРНУТЬСЯ</button>
        <button class="mc-btn" onclick="quit(false)">СОХРАНИТЬ И ВЫЙТИ</button>
    </div>

    <div id="inventory-screen" class="overlay-menu">
        <h2 style="color:white; text-shadow:2px 2px #000;">БЛОКИ</h2>
        <div class="inv-grid" id="creative-grid"></div>
        <div style="color:#aaa; margin-top:20px;">E - Закрыть</div>
    </div>
    <div id="cursor-item"></div>

    <div id="screen-error">
        <div class="err-title" id="err-header">ЗАГРУЗКА...</div>
        <div class="err-desc" id="err-msg">Проверка профиля</div>
        <button id="btn-menu" class="mc-btn" onclick="location.href='index.html'">В МЕНЮ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "firebase-app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
                "firebase-database": "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js",
                "firebase-auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from "firebase-app";
        // ДОБАВИЛ 'push' в импорты
        import { getDatabase, ref, set, update, push, remove, onChildAdded, onChildChanged, onChildRemoved, onDisconnect, onValue, get } from "firebase-database";
        import { getAuth, onAuthStateChanged } from "firebase-auth";

        const MODE = localStorage.getItem('mc_mode'); 
        const WORLD_NAME = localStorage.getItem('mc_current_world');
        const LOBBY_ID = localStorage.getItem('mc_lobby_id');
        const IS_HOST = (localStorage.getItem('mc_is_host') === 'true');
        const SETTINGS = JSON.parse(localStorage.getItem('mc_settings') || '{"sens":0.5, "dist":60}');
        
        const app = initializeApp({ apiKey: "AIzaSyA-ZeBBpiBMwqGVfGL9bSunUu_d2dXVgcI", authDomain: "minecraft-2ec53.firebaseapp.com", projectId: "minecraft-2ec53", storageBucket: "minecraft-2ec53.firebasestorage.app", messagingSenderId: "1065608540888", appId: "1:1065608540888:web:6d0a253399e3f6ff94ddad" });
        const db = getDatabase(app);
        const auth = getAuth(app);
        let currentUser = null, playerRef = null, statusRef = null, explosionsRef = null;

        let camera, scene, renderer, controls = null;
        const objects = []; let worldData = {}; const objectsMap = {}; const otherPlayers = {}; let raycaster;
        let isPaused = false, isGameRunning = false, isInvOpen = false;
        let moveF=0, moveB=0, moveL=0, moveR=0, canJump=false, isSprint=false, isCrouch=false;
        const velocity = new THREE.Vector3();
        let prevTime = performance.now(), lastUploadTime = 0;
        
        const WALK=5.0, SPRINT=8.0, CROUCH=3.0, JUMP=9, GRAVITY=24.0, P_W=0.5, P_H=1.8, EYE=1.6;
        
        const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
        let materials = [];
        const texUrls = [
            './textures/grass.png', './textures/dirt.png', './textures/stone.png', './textures/obsidian.png', './textures/iron.png', 
            './textures/log.png', './textures/planks.png', './textures/brick.png', './textures/sand.png', './textures/diamond.png',
            './textures/tnt.png', './textures/flint.png'
        ];
        
        let hotbar = [null,null,null,null,null,null,null,null,null], selSlot=0, holdBlock=null;
        const primedTNTs = []; 

        if(MODE === 'multi') {
            onAuthStateChanged(auth, user => {
                if(user) {
                    currentUser = user;
                    get(ref(db, `lobbies/${LOBBY_ID}/banned/${currentUser.uid}`)).then(snap => {
                        if(snap.exists()) showDisconnectScreen("Вы забанены", `Причина: ${snap.val().reason}`);
                        else checkAntiCheatAndStart();
                    }).catch(err => showDisconnectScreen("Ошибка", "Нет связи"));
                } else { window.location.href = 'index.html'; }
            });
        } else {
            hideLoadingScreen();
            startEngine();
            loadLocalWorld();
        }

        function checkAntiCheatAndStart() {
            const sRef = ref(db, `status/${currentUser.uid}`);
            get(sRef).then(snap => {
                const s = snap.val();
                if(s && s.state === 'online' && (Date.now() - s.last_seen < 15000)) {
                    showDisconnectScreen("Ошибка входа", "Двойной вход в аккаунт");
                } else {
                    statusRef = sRef;
                    set(statusRef, {state: 'online', last_seen: Date.now()});
                    onDisconnect(statusRef).set({state: 'offline'});
                    setInterval(() => set(ref(db, `status/${currentUser.uid}/last_seen`), Date.now()), 5000);
                    hideLoadingScreen();
                    startEngine();
                    connectToLobby();
                }
            });
        }

        function connectToLobby() {
            document.getElementById('info-panel').innerText = `Сервер: ${LOBBY_ID}`;
            genTerrain();
            
            // --- СЛУШАЕМ ВЗРЫВЫ ОТ ВСЕХ ИГРОКОВ ---
            explosionsRef = ref(db, `lobbies/${LOBBY_ID}/explosions`);
            // Очищаем старые взрывы при входе (необязательно, но полезно)
            // Но слушаем только новые
            onChildAdded(explosionsRef, (snap) => {
                const data = snap.val();
                if(data && (Date.now() - data.time < 2000)) { // Если взрыв свежий
                    performExplosion(data.x, data.y, data.z);
                }
            });

            onValue(ref(db, `lobbies/${LOBBY_ID}`), s => { 
                if(!s.exists()) quit(true, "Сервер удален", "Хост удалил этот мир"); 
                else if(s.val().status === 'offline' && !IS_HOST) quit(true, "Сервер остановлен", "Хост выключил сервер");
            });
            playerRef = ref(db, `lobbies/${LOBBY_ID}/players/${currentUser.uid}`);
            onDisconnect(playerRef).remove();
            set(playerRef, { x:0, y:20, z:0, rotation:0, nick: currentUser.displayName });

            onValue(playerRef, snap => {
                if(isGameRunning && snap.exists()) {
                    const data = snap.val();
                    if (data._forceKick) quit(true, "ВАС КИКНУЛИ", "Вы были отключены от сервера");
                    if (data._forceBan) {
                         get(ref(db, `lobbies/${LOBBY_ID}/banned/${currentUser.uid}`)).then(bSnap => {
                            const r = bSnap.exists() ? bSnap.val().reason : "Бан";
                            quit(true, "ВЫ ЗАБАНЕНЫ", `Причина: ${r}`);
                         });
                    }
                }
                if(isGameRunning && !snap.exists()) quit(true, "Отключено", "Потеряна связь с профилем");
            });

            const pRef = ref(db, `lobbies/${LOBBY_ID}/players`);
            onChildAdded(pRef, s => { if(s.key !== currentUser.uid) spawnPlayer(s.key, s.val()); });
            onChildChanged(pRef, s => { if(s.key !== currentUser.uid && otherPlayers[s.key]) movePlayer(s.key, s.val()); });
            onChildRemoved(pRef, s => { if(otherPlayers[s.key]) { scene.remove(otherPlayers[s.key].mesh); delete otherPlayers[s.key]; } });

            const wRef = ref(db, `lobbies/${LOBBY_ID}/world`);
            const handleUpdate = (snap) => {
                const [x,y,z] = snap.key.split('_').map(Number);
                const val = snap.val();
                const existing = objectsMap[`${x},${y},${z}`];
                if (existing && existing.userData.isPrimed) return;
                if (existing) removeBlockLocal(existing);
                if (val !== 99) createBlock(x,y,z, materials[val], true, false); 
            };
            onChildAdded(wRef, handleUpdate);
            onChildChanged(wRef, handleUpdate);
        }

        function hideLoadingScreen() {
            document.getElementById('screen-error').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
        }

        function showDisconnectScreen(title, msg) {
            document.getElementById('game-ui').style.display = 'none';
            document.getElementById('pause-menu').style.display = 'none';
            if(renderer) renderer.domElement.style.display = 'none';
            const screen = document.getElementById('screen-error');
            document.getElementById('err-header').innerText = title;
            document.getElementById('err-msg').innerText = msg;
            document.getElementById('btn-menu').style.display = 'block';
            screen.style.display = 'flex';
        }

        window.quit = (forced, title, msg) => {
            isGameRunning = false; 
            if(controls) controls.unlock();
            if(MODE === 'single' && !forced) saveLocalWorld();
            if(MODE === 'multi' && playerRef && !forced) remove(playerRef);
            if(statusRef) set(statusRef, {state: 'offline'}); 
            if(forced) showDisconnectScreen(title, msg);
            else window.location.href = 'index.html';
        };
        
        window.resume = () => { if(controls) { document.getElementById('pause-menu').style.display='none'; controls.lock(); } };

        function startEngine() { init3D(); isGameRunning = true; animate(); }

        function init3D() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 10, SETTINGS.dist);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.005, SETTINGS.dist * 2); camera.position.set(0, 15, 0);
            scene.add(new THREE.AmbientLight(0xcccccc)); 
            const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(10,20,10); scene.add(dl);
            controls = new PointerLockControls(camera, document.body); controls.pointerSpeed = SETTINGS.sens;
            controls.addEventListener('lock', () => { isPaused=false; document.getElementById('pause-menu').style.display='none'; isInvOpen=false; document.getElementById('inventory-screen').style.display='none'; });
            controls.addEventListener('unlock', () => { if(isInvOpen || !isGameRunning) return; isPaused=true; document.getElementById('pause-menu').style.display='flex'; });
            
            const l = new THREE.TextureLoader();
            try { materials = texUrls.map(u => new THREE.MeshLambertMaterial({ map: l.load(u, t=>{t.magFilter=THREE.NearestFilter}) })); } catch(e){}
            initUI();
            
            document.addEventListener('keydown', onKey); document.addEventListener('keyup', onKey);
            document.addEventListener('wheel', onWheel); document.addEventListener('mousedown', onClick);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('click', () => { if(isGameRunning && !isPaused && !isInvOpen && controls) controls.lock(); });
            
            raycaster = new THREE.Raycaster(); raycaster.far = 5;
            renderer = new THREE.WebGLRenderer({antialias: true}); renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });
        }

        function genTerrain() {
            const R = 12;
            for(let x=-R; x<R; x++) for(let z=-R; z<R; z++) {
                createBlock(x, 0, z, materials[0], false, true);
                for(let y=-1; y>=-4; y--) createBlock(x, y, z, materials[1], false, true);
                for(let y=-5; y>=-9; y--) createBlock(x, y, z, materials[2], false, true);
                createBlock(x, -10, z, materials[3], false, true);
            }
        }

        function getKey(x,y,z){return `${x},${y},${z}`;}
        function hasBlock(x,y,z){return worldData[getKey(Math.round(x),Math.round(y),Math.round(z))];}
        function createBlock(x,y,z,m,net=false, isGen=false) {
            const o = new THREE.Mesh(cubeGeo, m); o.position.set(x,y,z); scene.add(o); objects.push(o);
            const k = getKey(x,y,z); worldData[k]=true; objectsMap[k]=o;
            if(MODE === 'multi' && !net && !isGen) set(ref(db, `lobbies/${LOBBY_ID}/world/${x}_${y}_${z}`), materials.indexOf(m));
        }
        function removeBlockLocal(o) {
            scene.remove(o); objects.splice(objects.indexOf(o),1);
            const k = getKey(Math.round(o.position.x), Math.round(o.position.y), Math.round(o.position.z));
            delete worldData[k]; delete objectsMap[k];
        }

        function igniteTNT(mesh, delayTime = 3000) {
            if(mesh.userData.isPrimed) return; 
            mesh.userData.isPrimed = true;
            mesh.material = mesh.material.clone();
            
            primedTNTs.push({
                mesh: mesh,
                explodeTime: performance.now() + delayTime,
                nextBlink: performance.now() + 200,
                isWhite: false
            });
        }

        function updatePrimedTNTs(time) {
            for(let i = primedTNTs.length - 1; i >= 0; i--) {
                const tnt = primedTNTs[i];
                
                // ВРЕМЯ ВЗРЫВА
                if(time >= tnt.explodeTime) {
                    const bx = tnt.mesh.position.x;
                    const by = tnt.mesh.position.y;
                    const bz = tnt.mesh.position.z;

                    // Если мультиплеер - отправляем событие взрыва
                    if(MODE === 'multi') {
                        push(explosionsRef, { x: bx, y: by, z: bz, time: Date.now() });
                        // Сервер сам разошлет всем, и нам тоже
                    } else {
                        // Одиночная игра - взрываем сразу
                        performExplosion(bx, by, bz);
                    }

                    primedTNTs.splice(i, 1);
                    continue;
                }
                
                // Мигание
                if(time >= tnt.nextBlink) {
                    tnt.isWhite = !tnt.isWhite;
                    if(tnt.isWhite) tnt.mesh.material.emissive.setHex(0xffffff);
                    else tnt.mesh.material.emissive.setHex(0x000000);
                    const timeLeft = tnt.explodeTime - time;
                    const interval = timeLeft < 1000 ? 100 : 250;
                    tnt.nextBlink = time + interval;
                }
            }
        }

        // --- ГЛАВНАЯ ФУНКЦИЯ ВЗРЫВА (Вызывается и локально, и по сети) ---
        function performExplosion(cx, cy, cz) {
            const R = 4;
            
            // 1. Удаление блоков
            for(let x = cx - R; x <= cx + R; x++) {
                for(let y = cy - R; y <= cy + R; y++) {
                    for(let z = cz - R; z <= cz + R; z++) {
                        if(Math.sqrt((x-cx)**2 + (y-cy)**2 + (z-cz)**2) <= R) {
                            if(hasBlock(x,y,z)) {
                                const obj = objectsMap[`${x},${y},${z}`];
                                
                                if(materials.indexOf(obj.material) === 10 || (obj.material.map && obj.material.map.name === 'tnt')) {
                                    const delay = 200 + Math.random() * 300;
                                    igniteTNT(obj, delay); 
                                } else {
                                    if(!obj.userData.isPrimed) {
                                        removeBlockLocal(obj);
                                        // В мультиплеере каждый клиент удаляет блок у себя визуально,
                                        // но только инициатор взрыва должен обновить базу (чтобы не спамить)
                                        // НО для простоты: пусть инициатор (тот кто зажег) обновляет базу в updatePrimedTNTs,
                                        // А тут мы просто визуально чистим.
                                        // НО мы не знаем, кто инициатор. 
                                        // Поэтому просто визуально удаляем. База обновится отдельно.
                                        // P.S. В идеале тут нужен сложный код, но пока сойдет.
                                        if(MODE === 'multi') set(ref(db, `lobbies/${LOBBY_ID}/world/${x}_${y}_${z}`), 99);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 2. ОТБРАСЫВАНИЕ (ДЛЯ ВСЕХ)
            // Эта функция выполняется у КАЖДОГО игрока.
            // Значит, каждый игрок проверяет расстояние от СЕБЯ (camera.position) до взрыва.
            const dist = camera.position.distanceTo(new THREE.Vector3(cx, cy, cz));
            if(dist < R + 3) {
                const dir = new THREE.Vector3().subVectors(camera.position, new THREE.Vector3(cx, cy, cz)).normalize();
                
                // СИЛА УМЕНЬШЕНА В 10 РАЗ
                // Было: (R + 2 - dist) * 1.5 * 15
                // Стало: множитель 2.0 (горизонталь) и 1.5 (вертикаль)
                const force = Math.max(0, (R + 3 - dist)); 
                
                velocity.addScaledVector(dir, force * 2.0); // Слабый толчок
                velocity.y += force * 1.5; // Небольшой подброс
            }
        }

        function onClick(e) {
            if(isPaused || isInvOpen || !controls || !controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const i = raycaster.intersectObjects(objects);
            
            if(i.length > 0 && i[0].distance <= 5) {
                const obj = i[0].object;
                const heldItem = hotbar[selSlot];

                if(e.button === 2) { 
                    if(heldItem === 11) { // Зажигалка
                        const matIndex = materials.indexOf(obj.material);
                        if((matIndex === 10 || (obj.userData.isTNT)) && !obj.userData.isPrimed) {
                            igniteTNT(obj); 
                            return;
                        }
                        return;
                    }
                    if(heldItem === null) return;
                    
                    const p = i[0].object.position.clone().add(i[0].face.normal);
                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(camera.position.x, camera.position.y - (P_H/2) + 0.2, camera.position.z), 
                        new THREE.Vector3(P_W, P_H - 0.2, P_W)
                    );
                    const blockBox = new THREE.Box3().setFromCenterAndSize(p, new THREE.Vector3(1, 1, 1));
                    if (playerBox.intersectsBox(blockBox)) return; 

                    createBlock(p.x, p.y, p.z, materials[heldItem]);
                    if(heldItem === 10) {
                        const k = getKey(p.x, p.y, p.z);
                        if(objectsMap[k]) objectsMap[k].userData.isTNT = true;
                    }

                } else if(e.button === 0) { 
                    if(obj.userData.isPrimed) return;
                    const bx = Math.round(obj.position.x), by = Math.round(obj.position.y), bz = Math.round(obj.position.z);
                    removeBlockLocal(obj);
                    if(MODE === 'multi') set(ref(db, `lobbies/${LOBBY_ID}/world/${bx}_${by}_${bz}`), 99);
                }
            }
        }

        function spawnPlayer(id, data) {
            const g = new THREE.BoxGeometry(0.6, 1.8, 0.6); const m = new THREE.MeshLambertMaterial({color:0xff0000});
            const mesh = new THREE.Mesh(g, m);
            if(data.nick) {
                const c=document.createElement('canvas'); const x=c.getContext('2d'); c.width=256;c.height=64;
                x.fillStyle="rgba(0,0,0,0.5)"; x.fillRect(0,0,256,64); x.fillStyle="white"; x.font="30px Arial"; x.textAlign="center"; x.fillText(data.nick,128,42);
                const s = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c)})); s.position.y=1.6; s.scale.set(2,0.5,1); mesh.add(s);
            }
            mesh.position.set(data.x, data.y-0.9, data.z); 
            scene.add(mesh); 
            otherPlayers[id] = { mesh: mesh, targetPos: new THREE.Vector3(data.x, data.y-0.9, data.z), targetRot: data.rotation };
        }
        function movePlayer(id, data) {
            if(otherPlayers[id]) { otherPlayers[id].targetPos.set(data.x, data.y-0.9, data.z); otherPlayers[id].targetRot = data.rotation; }
        }

        function loadLocalWorld() {
            document.getElementById('info-panel').innerText = `Мир: ${WORLD_NAME}`;
            const worlds = JSON.parse(localStorage.getItem('mc_worlds') || '{}');
            const data = worlds[WORLD_NAME]?.blocks || {};
            genTerrain();
            if(Object.keys(data).length > 0) {
                for(let k in data) { 
                    const [x,y,z] = k.split(',').map(Number);
                    const mat = data[k];
                    if(hasBlock(x,y,z)) removeBlockLocal(objectsMap[`${x},${y},${z}`]);
                    createBlock(x,y,z, materials[mat], false, false); 
                    if(mat === 10) objectsMap[`${x},${y},${z}`].userData.isTNT = true;
                }
            }
        }

        function saveLocalWorld() {
            if(MODE !== 'single') return;
            const worlds = JSON.parse(localStorage.getItem('mc_worlds') || '{}');
            const b = {};
            for(let k in worldData) { if(objectsMap[k]) b[k] = materials.indexOf(objectsMap[k].material); }
            worlds[WORLD_NAME].blocks = b;
            localStorage.setItem('mc_worlds', JSON.stringify(worlds));
        }

        function onKey(e) {
            const down = e.type === 'keydown';
            if(e.code === 'KeyW') moveF = down; if(e.code === 'KeyS') moveB = down;
            if(e.code === 'KeyA') moveL = down; if(e.code === 'KeyD') moveR = down;
            if(e.code === 'Space') if(down && canJump && !isCrouch) { velocity.y += JUMP; canJump = false; }
            if(e.code === 'ControlLeft') isSprint = down; if(e.code === 'ShiftLeft') isCrouch = down;
            if(down && e.code === 'KeyE') {
                if(isInvOpen) { isInvOpen = false; document.getElementById('inventory-screen').style.display='none'; if(controls) controls.lock(); }
                else { isInvOpen = true; document.getElementById('inventory-screen').style.display='flex'; if(controls) controls.unlock(); }
            }
            if(down && e.code.startsWith('Digit')) { 
                const n = parseInt(e.code.slice(5))-1; 
                if(n>=0 && n<9) selectSlot(n);
            }
        }

        function resolveCol(pos) {
            const r = P_W / 2; 
            const minX = pos.x - r, maxX = pos.x + r; 
            const minZ = pos.z - r, maxZ = pos.z + r; 
            const minY = pos.y - EYE + 0.2; 
            const maxY = pos.y + (P_H - EYE);
            for(let y = Math.round(minY); y <= Math.round(maxY); y++) {
                for(let z = Math.round(minZ); z <= Math.round(maxZ); z++) {
                    for(let x = Math.round(minX); x <= Math.round(maxX); x++) {
                        if(hasBlock(x,y,z)) { 
                            if (maxX > x-0.5 && minX < x+0.5 && maxY > y-0.5 && minY < y+0.5 && maxZ > z-0.5 && minZ < z+0.5) return true; 
                        }
                    }
                }
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate); if(!isGameRunning || isPaused) return;
            const t = performance.now(), d = Math.min((t-prevTime)/1000, 0.05);
            
            updatePrimedTNTs(t);

            velocity.y -= GRAVITY * d;
            const fwd = Number(moveF) - Number(moveB); const right = Number(moveR) - Number(moveL);
            if(fwd !== 0 || right !== 0) {
                const front = new THREE.Vector3(); camera.getWorldDirection(front); front.y=0; front.normalize();
                const side = new THREE.Vector3(); side.crossVectors(front, camera.up).normalize();
                const dir = new THREE.Vector3(); dir.addScaledVector(front, fwd); dir.addScaledVector(side, right); dir.normalize();
                let s = isCrouch ? CROUCH : (isSprint ? SPRINT : WALK);
                velocity.x += dir.x * s * d * 10; velocity.z += dir.z * s * d * 10;
            }
            velocity.x -= velocity.x * 10.0 * d; velocity.z -= velocity.z * 10.0 * d;
            const pos = camera.position.clone();
            
            pos.x += velocity.x * d; if(resolveCol(pos)) { pos.x -= velocity.x * d; velocity.x = 0; }
            pos.z += velocity.z * d; if(resolveCol(pos)) { pos.z -= velocity.z * d; velocity.z = 0; }
            pos.y += velocity.y * d; 
            
            const r = P_W / 2; 
            const minX = pos.x - r, maxX = pos.x + r; 
            const minZ = pos.z - r, maxZ = pos.z + r; 
            const minY = pos.y - EYE; 
            const maxY = pos.y + (P_H - EYE);
            let colY = false;
            for(let y = Math.round(minY); y <= Math.round(maxY); y++) {
                for(let z = Math.round(minZ); z <= Math.round(maxZ); z++) {
                    for(let x = Math.round(minX); x <= Math.round(maxX); x++) {
                        if(hasBlock(x,y,z)) { 
                            if (maxX > x-0.5 && minX < x+0.5 && maxY > y-0.5 && minY < y+0.5 && maxZ > z-0.5 && minZ < z+0.5) colY = true; 
                        }
                    }
                }
            }
            
            if(colY) { 
                const fall = velocity.y < 0; 
                pos.y -= velocity.y * d; 
                velocity.y = 0; 
                if(fall) { canJump = true; pos.y = Math.round(pos.y - EYE - 0.5) + 0.5 + EYE; }
            }
            
            camera.position.copy(pos);
            if(camera.position.y < -30) { camera.position.set(0,30,0); velocity.y=0; }
            for (let id in otherPlayers) { const p = otherPlayers[id]; p.mesh.position.lerp(p.targetPos, 0.3); p.mesh.rotation.y += (p.targetRot - p.mesh.rotation.y) * 0.3; }
            
            if(MODE === 'multi' && t - lastUploadTime > 150) { 
                if(playerRef && isGameRunning) {
                    update(playerRef, {
                        x:camera.position.x, y:camera.position.y, z:camera.position.z, 
                        rotation:camera.rotation.y, nick:currentUser.displayName
                    }); 
                }
                lastUploadTime = t; 
            }
            prevTime = t; renderer.render(scene, camera);
        }

        function initUI() {
            const g = document.getElementById('creative-grid');
            texUrls.forEach((u,i) => { const d = document.createElement('div'); d.className='inv-slot'; d.style.backgroundImage=`url(${u})`; d.onclick = () => { holdBlock = i; updCur(u); }; g.appendChild(d); });
            for(let i=0; i<9; i++) document.getElementById(`slot-${i}`).onclick = () => { if(isInvOpen && holdBlock!==null) { hotbar[i]=holdBlock; updHot(); holdBlock=null; updCur(null); } };
        }
        function updCur(u) { const c=document.getElementById('cursor-item'); if(u){c.style.display='block';c.style.backgroundImage=`url(${u})`;}else c.style.display='none'; }
        function updHot() { for(let i=0;i<9;i++) { const s=document.getElementById(`slot-${i}`); s.style.backgroundImage = hotbar[i]!==null ? `url(${texUrls[hotbar[i]]})` : 'none'; } }
        function selectSlot(n) { selSlot=n; document.querySelectorAll('.slot').forEach(e=>e.classList.remove('active')); document.getElementById(`slot-${n}`).classList.add('active'); }
        function onWheel(e) { if(isPaused)return; if(e.deltaY>0){let s=selSlot+1;if(s>8)s=0;selectSlot(s);}else{let s=selSlot-1;if(s<0)s=8;selectSlot(s);} }
        function onMove(e) { if(isInvOpen && holdBlock!==null) { const c=document.getElementById('cursor-item'); c.style.left=e.clientX+'px'; c.style.top=e.clientY+'px'; } }
    </script>
</body>
</html>
